package logging

import (
	"goOnGo/internal/swapi-func/model/logging"
)

/*
Используя функциональный подход, мы описываем логику в виде функций, а зависимости передаем через аргументы.
Аргументы-зависимости - это так же функции, выполняющие какую-то единицу работы.
Такой подход называется композицией функций, а сами функции, реализующие композицию, называются функциями высшего порядка.

Зависимости можно объединить в структуру, такие структуры называются контекстом функции.
В Go контекст можно выразить через интерфейс, для того чтобы можно было использовать разные реализации.
Сам факт передачи зависимостей через структуру не меняет того что это функция высшего порядка,
лишь упрощает запись и улучшает читаемость кода.

У контекста есть важное свойство - он неизменяемый. Это значит что контекст не может измениться внутри функции.
Ни самой функцией, ни любым иным асинхронным способом. Иными словами, контекст - это коллекция чистых функций.

Следует правильно трактовать интерфейсы. Это выглядит похоже на ООП, но только похоже: ООП использует
интерфейсы для описания свойств, а функциональный подход использует интерфейсы для описания требований.
В более общем смысле это значит что там где ООП создает много интерфейсов, разделяя способы использования,
чтобы избежать ненужной зависимости, функциональный подход объединяет зависимости в один интерфейс,
чтобы передавать меньше параметров в функции. Интерфейс в функциональном подходе - это не абстракция, а контракт.

В более классическом виде, функциональный подход не использует интерфейсы, а передает зависимости
через структуры функций.
Но в Go интерфейсы - это удобный способ описания контрактов, без привязки к конкретным типам.
*/

type Context interface {
	Filter(record *logging.Record) bool
	Write(record *logging.Record)
}

func Log(ctx Context, level logging.Level, message string, labels ...*logging.Label) {
	record := logging.NewRecord(level, message, labels...)

	if ctx.Filter(record) {
		ctx.Write(record)
	}
}

func Info(ctx Context, message string, labels ...*logging.Label) {
	Log(ctx, logging.Info, message, labels...)
}

func Error(ctx Context, message string, labels ...*logging.Label) {
	Log(ctx, logging.Error, message, labels...)
}
